from fastapi import APIRouter, HTTPException, status, Depends
from pydantic import BaseModel, EmailStr, Field
from app.db.supabase import get_supabase
from app.core.auth import get_password_hash, verify_password, create_access_token
from datetime import date, timedelta
import secrets
import time

router = APIRouter()

class UserSignup(BaseModel):
    email: EmailStr
    password: str
    confirm_password: str
    username: str = Field(..., min_length=3, max_length=30, pattern="^[a-zA-Z0-9._-]+$")
    full_name: str
    dob: date

class UserSignin(BaseModel):
    email: EmailStr
    password: str

class AuthStart(BaseModel):
    email: EmailStr

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str
    confirm_password: str

class ResendConfirmationRequest(BaseModel):
    email: EmailStr
@router.post("/start")
async def auth_start(payload: AuthStart):
    supabase = get_supabase()
    response = supabase.table("users").select("id, password_hash").eq("email", payload.email).execute()
    if response.data:
        user = response.data[0]
        if user.get("password_hash"):
            return {"exists": True, "next": "password"}
        else:
            return {"exists": True, "next": "social_login"}
    return {"exists": False, "next": "create_account"}

@router.post("/signup", status_code=status.HTTP_201_CREATED)
async def signup(payload: UserSignup):
    if payload.password != payload.confirm_password:
        raise HTTPException(status_code=400, detail="Passwords do not match")
    
    supabase = get_supabase()
    # Check username uniqueness
    user_check = supabase.table("users").select("id").eq("username", payload.username).execute()
    if user_check.data:
        raise HTTPException(status_code=409, detail="Username already taken")

    # Create user
    hashed_password = get_password_hash(payload.password)
    user_data = {
        "email": payload.email,
        "password_hash": hashed_password,
        "username": payload.username,
        "full_name": payload.full_name,
        "dob": payload.dob.isoformat(),
        "email_confirmed": False
    }
    
    try:
        response = supabase.table("users").insert(user_data).execute()
        new_user = response.data[0]
        return {"user_id": new_user["id"], "next": "confirm_email"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/signin")
async def signin(payload: UserSignin):
    supabase = get_supabase()
    response = supabase.table("users").select("*").eq("email", payload.email).execute()
    if not response.data:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    user = response.data[0]
    if not verify_password(payload.password, user["password_hash"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if not user["email_confirmed"]:
        raise HTTPException(status_code=403, detail="Email not confirmed. Please verify your email address.")

    access_token = create_access_token(data={"sub": user["id"]})
    return {"access_token": access_token, "token_type": "bearer", "user": user}
@router.post("/confirm")
async def confirm_email(token: str):
    # Placeholder for email confirmation logic
    return {"message": "Email confirmed"}
